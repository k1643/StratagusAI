tree grammar GameStateEval;
options {
    tokenVocab=GameState;   // reuse tokens generated by GameState.g.
                             // without this token ID numbers don't match
                             // between parser and AST walker.
    ASTLabelType=CommonTree;
}
@header {
package orst.stratagusai.stratplan;
import orst.stratagusai.Player;
import orst.stratagusai.Unit;
import orst.stratagusai.WargusUnitPrototypes;
import orst.stratagusai.WargusUnitType;
import orst.stratagusai.stratplan.model.GameState;
import orst.stratagusai.stratplan.model.GameMap;
import orst.stratagusai.stratplan.model.Location;
import orst.stratagusai.stratplan.model.Rectangle;
import orst.stratagusai.stratplan.model.Region;
import orst.stratagusai.stratplan.model.MapNode;
import orst.stratagusai.stratplan.model.RegionNode;
import orst.stratagusai.stratplan.model.PassageNode;
import orst.stratagusai.stratplan.model.Passage;
import orst.stratagusai.stratplan.persist.GameMapReader;
import orst.stratagusai.stratplan.persist.UnitReader;
import org.apache.commons.beanutils.BeanUtils;
import java.lang.reflect.InvocationTargetException;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
}

@members {
    GameState game;

    /** store map nodes by ID for resolution */
    Map<Integer,PassageNode> pnodes;

    WargusUnitPrototypes prototypes = new WargusUnitPrototypes();

    /** reader to set Unit attributes.  Configuring a unit reader could be
      * used other projects to serialize Unit sub-classes. */
    UnitReader uReader = new UnitReader();
}

game_state returns [GameState s]
@init {
    game = new GameState();
}
    : ^(GAME_STATE CYCLE cycle=INT player+ map units) {
        game.setCycle(Integer.parseInt($cycle.text));
        $s = game; // set return value.
    };

/* (:player :id 0 :gold 2000 :wood 1000 :oil 1000 :supply 0 :demand 5) */
player
@init{
    // properties
    Map<String,Object> ps = new LinkedHashMap<String,Object>();
}
    : ^(PLAYER id=INT pair[ps]+) {
        Player p = new Player(Integer.parseInt($id.text));
        if (ps.get("gold") != null) {
            p.setGold(Integer.parseInt(ps.get("gold").toString()));
        }
        //wood
        if (ps.get("wood") != null) {
            p.setWood(Integer.parseInt(ps.get("wood").toString()));
        }
        //oil
        if (ps.get("oil") != null) {
            p.setOil(Integer.parseInt(ps.get("oil").toString()));
        }
        //supply
        if (ps.get("supply") != null) {
            p.setSupply(Integer.parseInt(ps.get("supply").toString()));
        }
        //demand
        if (ps.get("demand") != null) {
            p.setDemand(Integer.parseInt(ps.get("demand").toString()));
        }
        game.addPlayer(p);
    };

map returns [GameMap map]
@init{
    pnodes = new LinkedHashMap<Integer,PassageNode>();
    map = new GameMap();
}
    : ^(GAME_MAP cells[map]? region[map]+ cnx[map]) {
        if (game != null) {
            game.setMap(map);
        }
    }
    | ^(GAME_MAP RESOURCE s=STRING) {
        try {
            String resourceName = $s.text.replace("'","");
            InputStream is =
                    ClassLoader.getSystemResourceAsStream(resourceName);
            BufferedReader br = new BufferedReader(new InputStreamReader(is));
            map = GameMapReader.load(br);
            if (game != null) {
                game.setMap(map);
            }
        } catch (IOException ex) {
            throw new RuntimeException(ex);
        }
    };

cells[GameMap map]
@init {
    List<String> rows = new ArrayList<String>();
}
    : ^(CELLS map_row[rows]+) {
        if (!rows.isEmpty()) {
            String first = rows.get(0);
            first = first.substring(1,first.length()-1);  // remove quotes.
            int cols = first.length();
            char[][] cs = new char[rows.size()][];
            for (int i = 0; i < cs.length; i++) {
                String s = rows.get(i);
                s = s.substring(1,s.length()-1);
                if (s.length() != cols) {
                    throw new RuntimeException("cell row lengths don't match at row " + i);
                }
                cs[i] = s.toCharArray();
            }
            map.setCells(cs);
        }
    };

map_row[List<String> rows]
    : row=STRING {
        rows.add($row.text);
    };

region[GameMap map]
@init{
    Region r = new Region();
}
    : ^(REGION id=INT loc=location ck=chokepoint? rect[r]+) {
        r.setId(Integer.parseInt($id.text));
        if (ck) {
            r.setChokepoint(true);
        }
        r.setX(loc.getX());
        r.setY(loc.getY());
        map.addRegion(r);      
    };

location returns [Location loc]
    : ^(x=INT y=INT) {
        loc = new Location(
            Integer.parseInt($x.text),
            Integer.parseInt($y.text));
    };

/** this is a bit roundabout, but it's the only way I figured out how to turn
 * the presence or absence of ':chokepoint' into a boolean. */
chokepoint returns [boolean ck]
    : ':chokepoint' {
        ck = true;
    };

rect[Region region]
    : ^(minX=INT minY=INT maxX=INT maxY=INT) {
        Rectangle r = new Rectangle(
            Integer.parseInt($minX.text),
            Integer.parseInt($minY.text),
            Integer.parseInt($maxX.text),
            Integer.parseInt($maxY.text)
                   );
        region.addRectangle(r);
    };

cnx[GameMap map]
    : '(' ':connections' pnode+ passage[map]+ ')';

passage[GameMap map]
@init{
    // properties
    Map<String,Object> ps = new LinkedHashMap<String,Object>();
/* (:Passage :regionNode 2 :passageNode 1) */
}
    : ^(PASSAGE pair[ps] pair[ps]) {
        // pnodes and regions should have been stored now.
        int rid = Integer.parseInt(ps.get("regionNode").toString());
        int pid = Integer.parseInt(ps.get("passageNode").toString());
        Region r = map.getRegion(rid);
        RegionNode rn = r.getNode();
        PassageNode pn = pnodes.get(pid);
        Passage p = new Passage(rn, pn);
        map.addPassage(p);
    };

pnode
    : ^(PASSAGE_NODE idStr=INT loc=location) {
        PassageNode p = new PassageNode(Integer.parseInt($idStr.text));
        pnodes.put(p.getId(), p);
        p.setX(loc.getX());
        p.setY(loc.getY());
    };

units
    : ^(UNITS unit*);

unit
@init{
    // properties
    Map<String,Object> ps = new LinkedHashMap<String,Object>();
}
    : ^(UNIT pair[ps]+) {
        Unit u = uReader.readUnit(ps);  // create Unit and set attributes.
        game.addUnit(u);
    };

pair[Map<String,Object> properties]
    : label=LABEL (i=INT|s=NAME) {
        String name = $label.text.substring(1);
        if (i != null) {
            properties.put(name,new Integer($i.text));
        } else {
            properties.put(name,$s.text);
        }
    };
