tree grammar PlanEval;
options {
    tokenVocab=Plan;   // reuse tokens generated by Plan.g.
                             // without this token ID numbers don't match
                             // between parser and AST walker.
    ASTLabelType=CommonTree;
}
@header {
package orst.stratagusai.stratplan;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import orst.stratagusai.stratplan.UnitGroup;
}

@members {
    StrategicPlan plan;

    // tasks and triggers maps are used to resolve trigger links between tasks
    // after the parse is done.

    /** task name to task object map. */
    Map<String,Task> tasks = new LinkedHashMap<String,Task>();

    /** unit group specifications */
    Map<Integer,UnitGroup> groupSpecs = new LinkedHashMap<Integer,UnitGroup>();

    /** map task to specification of outgoing triggers. */
    Map<Task,List<String>> triggers = new LinkedHashMap<Task,List<String>>();

    public void resolveTriggers() {
        for (Task task : tasks.values()) {
            List<String> specs = triggers.get(task);
            if (specs == null) {
                continue;
            }
            for (String spec : specs) {
                String[] words = spec.split("\\s");
                assert words.length == 3 : "invalid trigger spec: " + spec;

                Task trgTask = tasks.get(words[2]);
                assert trgTask != null : "unknown task: " + words[2];

                TriggerType trigType;
                if (":start".equals(words[0])) {
                    if ("start".equals(words[1])) {
                        trigType = TriggerType.StartStart;
                    } else if ("end".equals(words[1])) {
                        trigType = TriggerType.StartEnd;
                    } else {
                        throw new RuntimeException("unknown trigger target: " + words[1]);
                    }
                } else if (":end".equals(words[0])) {
                    if ("start".equals(words[1])) {
                        trigType = TriggerType.EndStart;
                    } else if ("end".equals(words[1])) {
                        trigType = TriggerType.EndEnd;
                    } else {
                        throw new RuntimeException("unknown trigger target: " + words[1]);
                    }
                } else {
                    throw new RuntimeException("unknown trigger source: " + words[0]);
                }
                plan.addTrigger(task, trgTask, trigType);
            }
        }
    }
}

plan returns [StrategicPlan s]
@init{
    plan = new StrategicPlan();  // the global plan
}
    : '(' ':plan' NAME ':player' player=INT group_spec[plan]* task[plan]* ')' {
        plan.setName($NAME.text);
        plan.setPlayerId(Integer.parseInt($player.text));
        resolveTriggers();
        for (UnitGroup g : groupSpecs.values()) {
            g.setOwnerId(plan.getPlayerId());
        }
        plan.setGroups(groupSpecs);
        $s = plan;  // set return value
    };

group_spec[StrategicPlan plan]
@init {
    UnitGroup group = new UnitGroup();
}
//    : '(' ':group-spec' idStr=INT units_spec[groupSpec]* (':initial-units' '(' (unitId=INT{
//            groupSpec.addInitialUnitId(Integer.parseInt($unitId.text));
//                                                                        })* ')')? ')' {
    : '(' ':group-spec' idStr=INT ':type' type=NAME units_spec[group]* (':initial-units' '(' ( INT )* ')')? ')' {
        int id = Integer.parseInt($idStr.text);
        group.setId(id);
        group.setType($type.text);
        groupSpecs.put(id,group);
    };

units_spec[UnitGroup group]
    : name=NAME valueStr=INT {
        Argument spec = new Argument();
        spec.setName($name.text);
        int value = Integer.parseInt($valueStr.text);
        spec.setValue(value);
        group.addUnitTypeReq(spec);
    };

task[StrategicPlan plan]
@init {
    Task task = new Task();
    List<String> specs = new ArrayList<String>(); // trigger specifications
}
    : '(' ':task' name=NAME task_args[task]
          ':type' t=NAME
          (':using' groupIdStr=INT)?
          (':start' start_triggers[specs])?
          (':end'   end_triggers[specs])? ')' {
        // check for unique name
        if (tasks.containsKey($name.text)) {
            throw new RuntimeException("Duplicate task name '" + $name.text + "'");
        }
        task.setName($name.text);
        task.setType($t.text);
        tasks.put(task.getName(), task);
        triggers.put(task, specs); // save specs for resolution after parsing.

        if ($groupIdStr != null) {
            int groupId = Integer.parseInt($groupIdStr.text);
            task.setUsing(groupId);
        }

        plan.addTask(task);
    };

task_args[Task task]
@init{
    gid = -1;
    rid = -1;
}
    : '(' gid=group_arg? (rid=region_arg)? ')' {
        if (gid != -1) {
            UnitGroup g = groupSpecs.get(gid);
            task.setTargetGroup(g);
        }
        if (rid != -1) {
            task.setTargetRegionId(rid);
        }
    };

group_arg returns [int groupId]
    : '(' ':group' id=INT ')' {
        $groupId = Integer.parseInt($id.text);
    };

task_arg[List<Argument> args]
    : ((name=NAME value=INT)|name=NAME) {
        Argument arg = new Argument($name.text);
        args.add(arg);
        if ($value != null) {
            arg.setValue(Integer.parseInt($value.text));
        }
    };

region_arg returns [int regionId]
    : '(' ':region' id=INT ')' {
        $regionId = Integer.parseInt($id.text);
    };

start_triggers[List<String> specs]
    : '(' ':trigger' trigger[":start", specs]* ')' ;

end_triggers[List<String> specs]
    : '(' ':trigger' trigger[":end", specs]* ')' ;

trigger[String src, List<String> specs]
    : '(' trg=('start' | 'end') NAME ')' {
        specs.add(src + " " + $trg.text + " " + $NAME.text);
    };

